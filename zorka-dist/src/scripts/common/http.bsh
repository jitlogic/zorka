/**
 * Copyright 2012-2013 Rafal Lewczuk <rafal.lewczuk@jitlogic.com>
 *
 * ZORKA is free software. You can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * ZORKA is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * ZORKA. If not, see <http://www.gnu.org/licenses/>.
 */


__http() {

  // Default values for HTTP stats
  zorka.defCfg("http.stats", "yes");
  zorka.defCfg("http.stats.congestion", "yes");
  zorka.defCfg("http.stats.mbean", "zorka:type=ZorkaStats,name=HttpStats");

  // Default values for HTTP parameter processing
  zorka.defCfg("http.params", "no");
  zorka.defCfg("http.params.include", "~.*");
  zorka.defCfg("http.params.exclude", "");

  // Default values for HTTP slow requests log configuration options
  zorka.defCfg("http.slow", "no");
  zorka.defCfg("http.slow.time", "5000");
  zorka.defCfg("http.slow.file", zorka.boolCfg("http.slow"));
  zorka.defCfg("http.slow.file.path", zorka.path("${zorka.log.dir}", "http-slow.log"));
  zorka.defCfg("http.slow.file.max", "8M");
  zorka.defCfg("http.slow.file.num", "8");
  zorka.defCfg("http.slow.format", "[${TIME}] ${URI}${PARAMS} -> ${STATUS}");

  // Default values for HTTP error log configuration options
  zorka.defCfg("http.error", "no");
  zorka.defCfg("http.error.codes", "400,404,405,406,407,408,409,410,411,412,413,414,415,416,417,419,420,422,423,424,"
    + "425,426,428,429,431,444,451,500,501,502,503,504,505,506,507,508,510,598,599");
  zorka.defCfg("http.error.file", zorka.boolCfg("http.error"));
  zorka.defCfg("http.error.file.path", zorka.path("${zorka.log.dir}", "http-error.log"));
  zorka.defCfg("http.error.file.max", "8M");
  zorka.defCfg("http.error.file.num", "8");
  zorka.defCfg("http.error.format", "[${TIME}] ${URI}${PARAMS} -> ${STATUS}");

  // Default values for HTTP tracer options 
  zorka.defCfg("http.trace", zorka.stringCfg("tracer"));
  zorka.defCfg("http.trace.time", "1000");
  zorka.defCfg("http.trace.params.prefix", "P_");

  _trace = zorka.boolCfg("http.trace");
  _stats = zorka.boolCfg("http.stats");
  _congestion = zorka.boolCfg("http.stats.congestion");
  _mbean = zorka.stringCfg("http.stats.mbean");
  _action = _congestion ? spy.ACTION_EXIT|spy.ACTION_STATS : spy.ACTION_STATS;
  _slow = zorka.boolCfg("http.slow");
  _slowF = _slow && zorka.boolCfg("http.slow.file");
  _params = zorka.boolCfg("http.params");
  _prefix = zorka.stringCfg("http.trace.params.prefix");
  _error = zorka.boolCfg("http.error");
  _errorF = zorka.boolCfg("http.error.file");
  _excludedParams = zorka.setCfg("http.params.exclude");

  slow_ft = _slowF ? zorka.rollingFileTrapper("http.slow", "INFO", zorka.stringCfg("http.slow.file.path"),
                     zorka.intCfg("http.slow.file.num"), zorka.kiloCfg("http.slow.file.max"), false) : null;

  error_ft = _errorF ? zorka.rollingFileTrapper("http.error", "INFO", zorka.stringCfg("http.error.file.path"),
                       zorka.intCfg("http.error.file.num"), zorka.kiloCfg("http.error.file.max"), false) : null;

  _errors = zorka.setCfg("http.error.codes");

  param_processor() {
    process(rec) {
      sb = new StringBuilder();
      pmap = rec.get("REQ").getParameterMap();
      for (e : pmap.entrySet()) {
        String k = e.getKey();
        if (_excludedParams.contains(k)) continue;
        String v = e.getValue().length > 0 ? e.getValue()[0] : "";
        if (_trace) { tracer.newAttr(_prefix+k, v); }
        c = sb.length() > 0 ? "&" : "?";
        sb.append(c + k + "=" + v);
      }
      rec.put("PARAMS", sb.toString());
      return rec;
    }
    return (com.jitlogic.zorka.core.spy.SpyProcessor)this;
  }


  error_marker() {
    process(rec) {
      rec.put(".STAGES", (rec.get(".STAGES")|(1<<spy.ON_ERROR))&(~(1<<spy.ON_RETURN)));
      return rec;
    }
    return (com.jitlogic.zorka.core.spy.SpyProcessor)this;
  }


  discovery(attr, tag) {
    return zabbix.discovery(zorka.query("java", _mbean, "name", "type").get(attr).listAs("**", tag));
  }

  calls(attr, tag) {
    calls = zorka.jmx("java", _mbean, attr, tag, "calls");
    return calls != null ? calls : 0;
  }

  errors(attr, tag) {
    errors = zorka.jmx("java", _mbean, attr, tag, "errors");
    return errors != null ? errors : 0;
  }

  peak(attr, tag) {
    peak = zorka.jmx("java",  _mbean, attr, tag, "maxTimeCLR");
    return peak != null ? peak : 0;
  }

  threads(attr, tag) {
    threads = zorka.jmx("java",  _mbean, attr, tag, "maxThreadsCLR");
  }

  avg5(attr, tag) {
    return zorka.rate("java", _mbean, attr, tag, "time", "calls", "AVG5");
  }

  avg15(attr, tag) {
    return zorka.rate("java", _mbean, attr, tag, "time", "calls", "AVG15");
  }

  return this;
}

http = __http();

