/**
 * Copyright 2012-2018 Rafal Lewczuk <rafal.lewczuk@jitlogic.com>
 *
 * ZORKA is free software. You can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * ZORKA is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * ZORKA. If not, see <http://www.gnu.org/licenses/>.
 */

__jvm() {

  autoregister() {
      if (!zorka.isMbsRegistered("java")) {
          mbs = java.lang.management.ManagementFactory.getPlatformMBeanServer();
          zorka.registerMbs("java", mbs);
          zorka.logInfo("Registered platform mbean server as 'java'");
      } else {
          zorka.logInfo("Platform mbean server already registered. Skipping.");
      }
  }


  autoregister_plugin() {
      process(rec) {
          autoregister();
          return rec;
      }
      return (com.jitlogic.zorka.core.spy.SpyProcessor)this;
  }


  memutil(name) {
    mem_used = zorka.jmx("java", "java.lang:name="+name+",type=MemoryPool", "Usage", "used");
    mem_max = zorka.jmx("java", "java.lang:name="+name+",type=MemoryPool", "PeakUsage", "max");
    if (mem_used == null || mem_max == null) return null;
    if (mem_used.equals(0L) || mem_max.equals(0L)) return 0.0;
    return 100.0 * mem_used.longValue() / mem_max.longValue();
  }

  heaputil(name) {
    mem_used = zorka.jmx("java", "java.lang:type=Memory",name, "used");
    mem_max = zorka.jmx("java", "java.lang:type=Memory",name, "max");
    if (mem_used == null || mem_max == null) return null;
    if (mem_used.equals(0L) || mem_max.equals(0L)) return 0.0;
    return 100.0 * mem_used.longValue() / mem_max.longValue();
  }

  fdutil() {
    fd_used = zorka.jmx("java", "java.lang:type=OperatingSystem", "OpenFileDescriptorCount");
    fd_max = zorka.jmx("java", "java.lang:type=OperatingSystem", "MaxFileDescriptorCount");
    if (fd_used == null || fd_max == null) return null;
    if (fd_used.equals(0L) || fd_max.equals(0L)) return 0.0;
    return 100.0 * fd_used.longValue() / fd_max.longValue();
  }

  if (zorka.boolCfg("jvm.hiccup", true)) {
    mbean = zorka.stringCfg("jvm.hiccup.mbean", "zorka:type=ZorkaStats,name=Hiccup");
    perfmon.cpuHiccup("java", mbean, "CPU", 10, 30000).start();
  } // hiccup = yes

  if (zorka.boolCfg("nagios", false)) {

    // Monitor memory pools
    nagios.defcmd("MEM_POOL", nagios.jmxscan(
      zorka.query("java", "java.lang:type=MemoryPool,*", "type", "name").get("Usage").get("used")
        .metric(perfmon.metric("java.lang", "LVAL0", "Memory pool ${ATTR.name} usage", "B").divide(1048576)),   // TODO czemu dzielenie nie działa ?
      zorka.query("java", "java.lang:type=MemoryPool,*", "type", "name").get("Usage")
        .metric(perfmon.util("java.lang", "LVAL1", "Memory pool ${ATTR.name} utilization", "%", "used", "max")),
      zorka.query("java", "java.lang:type=MemoryPool,*", "type", "name").get("Usage").get("max")
        .metric(perfmon.metric("java.lang", "LVAL2", "Memory pool ${ATTR.name} limit", "B").divide(1048576))    // TODO czemu dzielenie nie działa ?
      ).withLabel("${name}")                                                                       // TODO to jest kiepskie - powinno być ${ATTR.name}
       .withRcMax("LVAL1",
         zorka.longCfg("nagios.cmd.MEM_POOL.warn", 80),
         zorka.longCfg("nagios.cmd.MEM_POOL.alrt", 90))
       .withFilterResult("name", "Tenured Gen", "PS Old Gen", "CMS Old Gen", "G1 Old Gen")
       .withSummaryLine("MEM_POOL ${STATUS} - ${ATTR.name} ${LVAL0} B (${LVAL1}%); ")
       .withPerfLine("${LABEL}=${LVAL0}B;${LVAL0};${LVAL2};${LVAL1}")
       .withTextLine("${ATTR.name} ${LVAL0} B (${LVAL1}%); "));

    // Monitor Garbage Collectors
    nagios.defcmd("GC", nagios.jmxscan(
      zorka.query("java", "java.lang:type=GarbageCollector,*", "type", "name").get("CollectionCount")
        .metric(perfmon.timedDelta("java.lang", "LVAL0", "GC cycle frequency", "cycles/min").divide(1000).multiply(60)),
      zorka.query("java", "java.lang:type=GarbageCollector,*", "type", "name").get("CollectionTime")
        .metric(perfmon.timedDelta("java.lang", "LVAL1", "GC CPU time", "%CPU").divide(10))
      ).withLabel("${name}")                                                                       // TODO to jest kiepskie - powinno być ${ATTR.name}
       .withRcMax("LVAL1",
         zorka.longCfg("nagios.cmd.GC.warn", 10),
         zorka.longCfg("nagios.cmd.GC.alrt", 25))
       .withFilterResult("name", "MarkSweepCompact", "PS MarkSweep", "ConcurrentMarkSweep", "G1 Old Generation")
       .withSummaryLine("GC ${STATUS} - ${ATTR.name} ${LVAL1} %CPU; ")
       .withPerfLine("${LABEL}=${LVAL0}%;${LVAL1}")
       .withTextLine("${ATTR.name} ${LVAL1} %CPU; "));

    // Monitor Threads
    nagios.defcmd("THREAD", nagios.jmxscan(
      zorka.query("java", "java.lang:type=Threading", "type").get("ThreadCount")
        .metric(perfmon.metric("java.lang", "LVAL0", "JVM threads total", "threads")),
      zorka.query("java", "java.lang:type=Threading", "type").get("DaemonThreadCount")
        .metric(perfmon.metric("java.lang", "LVAL1", "JVM daemon threads", "threads")),
      zorka.query("java", "java.lang:type=Threading", "type").get("TotalStartedThreadCount")
        .metric(perfmon.timedDelta("java.lang", "LVAL2", "JVM threads creation", "threads/min").multiply(60))
      ).withLabel("Threads")
       .withRcMax("LVAL0",
         zorka.longCfg("nagios.cmd.THREAD.warn", 500),
         zorka.longCfg("nagios.cmd.THREAD.alrt", 700))
       .withFirstResult()
       .withSummaryLine("THREAD ${STATUS} ${LVAL0} thr (${LVAL2} thr/min); ")
       .withPerfLine("${LABEL}=${LVAL0};${LVAL1};${LVAL2}")
       .withTextLine("Threads ${LVAL0} thr (${LVAL2} thr/min}); "));
  }

  __http_client() {

    clazzes = zorka.listCfg("jvm.httpclient.classes",
      "java.net.HttpURLConnection",
      "sun.net.www.protocol.http.HttpURLConnection",
      "javax.net.ssl.HttpsURLConnection",
      "com.sun.net.ssl.HttpsURLConnection",
      "weblogic.net.http.HttpURLConnection",
      "weblogic.net.http.HttpsURLConnection");


    debug() {
      process(rec) {
        t = rec.get("THIS");
        id = System.identityHashCode(t);
        tracer.newAttr("XXX_OBJ_ID", ""+id);
        ctx = rec.get(".CTX");
        if (ctx != null) {
          zorka.logInfo("Called: " + ctx.getClassName() + "." + ctx.getMethodName() + "(): [" + ctx.getId() + "] " + id + " " + t);
        }
        return rec;
      }

      return (com.jitlogic.zorka.core.spy.SpyProcessor)this;
    }

    //for (clazz : clazzes) {
    //  spy.add(spy.instrument("DEBUG."+clazz).onEnter(spy.fetchArg("THIS", 0), debug()).include(spy.byMethod(0, clazz, "~.*", null)));
    //}

    jhci = instr.jvmHttpClient("JVM_HTTP_CLIENT");

    if (zorka.boolCfg("jvm.httpclient.trace", false)) {

      hdef = jhci[0];
      sdef = jhci[1];

      for (clazz : clazzes) {
        hdef = hdef.include(spy.byMethod(clazz, "setRequestMethod"));
        sdef = sdef.include(spy.byMethod(clazz, "getResponseCode"));
      }

      spy.add(hdef);
      spy.add(sdef);
    }

    return this;
  }

  http_client = __http_client();


  if (zorka.boolCfg("zorka.mbs.autoregister", false)) {
    autoregister();
  }

  if (zorka.boolCfg("zabbix.active")) {
    zorka.require("zabbix.bsh");
    zabbix.tagMetadata("JVM");
  }

  return this;
}


jvm = __jvm();
